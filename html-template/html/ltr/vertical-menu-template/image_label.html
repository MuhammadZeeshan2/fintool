{% load static %}
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>DREgine: medicDX</title>
  <link rel="shortcut icon" type="image/x-icon" href="{% static 'images/ico/logo.png' %}">
	<!-- ===========STYLE================ -->
	<link rel="stylesheet" type="text/css" href="{% static 'css/image-label/bootstrap.min.css' %}">
	<link rel="stylesheet" type="text/css" href="{% static 'css/image-label/style.css' %}">
	<link rel="stylesheet" type="text/css" href="{% static 'css/image-label/responsive.css' %}">
</head>

<body>

  <section class="my-3">
    {% include 'image_adjustment.html' %}
    <div class="container-fluid">
      <div class="row">
        <div class="col-md-2">
          <div class="edit-tools">
            <h3 class="mb-3">Editing Tools</h3>
            <ul>
              <li><button class="btn-edit tool-button" id="btn-select"><i class="fas fa-image"></i> Select Image</button></li>
              <li><button class="btn-edit tool-button" id="btn-fit-screen"><i class="fas fa-compress-arrows-alt"></i> Fit to Screen</button></li>
              <li><button class="btn-edit tool-button" id="btn-select-element"><i class="fas fa-hand-pointer"></i> Select Element</button></li>
              <li><button class="btn-edit tool-button" id="btn-blackout"><i class="fas fa-square"></i> Blackout</button></li>
              <li><button class="btn-edit tool-button" id="btn-line"><i class="fas fa-pencil-alt"></i> Draw Line</button></li>
              <li><button class="btn-edit tool-button" id="btn-rectangle"><i class="fas fa-square-full"></i> Draw Rectangle</button></li>
              <li><button class="btn-edit tool-button" id="btn-polygon"><i class="fas fa-draw-polygon"></i> Draw Polygon</button></li>
              <li><button class="btn-edit tool-button" id="btn-crop"><i class="fas fa-crop"></i> Crop Image</button></li>
              <!-- <li><button class="btn-edit tool-button" id="btn-circle"><i class="fas fa-circle"></i> Draw Circle</button></li>
              <li><button class="btn-edit tool-button" id="freeDraw"><i class="fas fa-draw-polygon"></i> Free Draw</button></li> -->

              <li><button class="btn-edit tool-button" id="btn-edit-labels" onclick="openEditLabels();"><i class="fas fa-font"></i> Edit Labels</button></li>
              <li><label class="mt-3 mb-2">Color Picker:</label></li>
              <li><input type="color" id="color-picker" value="#000000"></li>
              <li><label class="mt-3 mb-2">How to?</label></li>
              <li><div><ul class="how_to" id="how_to"></ul></div></li>
            </ul>
          </div>
        </div>
        <div class="col-md-8 position-relative">
          <div class="row top-canvus-elements-bar">

            <!-- <div class="custom-switch">
              <label class="switch-label" for="customSwitch">Hide Elements</label>
              <label class="switch">
                <input id="hide-elements" type="checkbox">
                <span class="slider round"></span>
              </label>
            </div> -->

            <div class="d-flex align-items-center justify-content-between">
              <div class="left-elements">
                <label class="form-check-label me-2" for="">Hide Elements</label>
                <div class="form-check form-switch">
                  <input class="form-check-input" type="checkbox" id="hide-elements">
                </div>
                <button class="btn-elements" id="zoom-out" data-toggle="tooltip" data-placement="top" title="Zoom Out">
                    <i class="fas fa-search-minus"></i>
                </button>
                <button class="btn-elements" id="zoom-in" data-toggle="tooltip" data-placement="top" title="Zoom In">
                  <i class="fas fa-search-plus"></i>
                </button>
                <button id="btn-reset" class="btn-elements tool-button" data-toggle="tooltip" data-placement="top" title="Reset ALL">
                  <i class="fas fa-refresh"></i>
                </button>
                <button id="btn-remove" class="btn-elements tool-button" disabled data-toggle="tooltip" data-placement="top" title="Delete Selected"><i class="fas fa-trash"></i></button>
                <button id="btn-edit-label" class="btn-elements tool-button" disabled data-toggle="tooltip" data-placement="top" title="Edit Selected Label"><i class="fas fa-edit"></i></button>
                <button class="btn-elements" id="undo" data-toggle="tooltip" data-placement="top" title="Undo"><i class="fas fa-undo"></i></button>
                <button class="btn-elements" id="redo" data-toggle="tooltip" data-placement="top" title="Redo"><i class="fas fa-redo"></i></button>
              </div>
              <div class="right-elements">
                <button id="" class="btn-elements tool-button right-btns" onclick="window.history.back();" data-toggle="tooltip" data-placement="top" title="Cancel Editing">Cancel</button>
                <button id="" class="btn-elements tool-button right-btns m-0" onclick="myFunction()" data-toggle="tooltip" data-placement="top" title="Submit Editing">Submit</button>
              </div>
            </div>
          </div>
          <div class="row row2">
            <div class="h-manage">
              <div class="canvus-box-custom pt-0 mb-3">
                <div class="hovered-label py-1">
                  <span id="hovered-lebel">Hover on the highlighted portion to see the associated label</span>
                </div>
                <div class="image-wrap" id="image-container">
                  <canvas id="image"></canvas>
                </div>
                <form class="post-form form form-horizontal" id="form1" method="POST" action="{% url 'image-label-submit' image.id %}">
                  {% csrf_token %}
                  <input type="hidden" name="canvasData" id="my_hidden" hidden>
                  <input type="hidden" name="components" id="my_components" hidden>
                  <input type="hidden" name="all_labels" id="all_labels" hidden>
                  <input type="hidden" name="uploaded_labels" id="uploaded_labels" hidden>
                </form>
              </div>
            </div>
          </div>
        </div>
        <div class="col-md-2">
          <div class="labels-keywords-container justify-content-center">
            <h5>Labels</h5>
            <button type="button" class="btn btn-primary" style="margin-top: 10px;" onclick="window.history.back()">Go Back</button>
            <div class="keywords-wrapper">
              <ul class="keywords-list" id="keywords">
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- =============modal============== -->
  <div class="modal fade" id="EditModel" tabindex="-1" role="dialog" aria-labelledby="EditModelTitle" aria-hidden="true">
      <div class="modal-dialog modal-dialog-centered modal-dialog-centered modal-dialog-scrollable" role="document">
          <div class="modal-content">
              <div class="modal-header">
                <div class="d-flex justify-content-between align-items-center w-100">
                    <h5 class="modal-title" id="EditModelTitle">Labels</h5>
                    <button type="button" class="close" data-bs-dismiss="modal" aria-label="Close">
                      <span aria-hidden="true">&times;</span>
                    </button>
                </div>
              </div>
              <div class="modal-body">
                <input type="file" id="fileInput" hidden>
                <div id="labelContainer">
                  <label for="existingLabels" class="form-label">Select Existing Labels:</label>
                  <select id="existingLabels" class="form-select mb-3">
                      <option value="">Select Label</option>
                      {% for label in labels %}
                          <option value="{{ label.id }}">{{ label.name }}</option>
                      {% endfor %}
                  </select>
                  <div class="row label-input">
                    <div class="col-8">
                      <input class="label-text form-control" type="text" placeholder="Insert label">
                    </div>
                    <div class="col-2">
                      <input class="color-input form-control" type="color" value="#007fff">
                    </div>
                    <div class="col-2">
                      <button class="delete-button btn btn-danger" onclick="deleteLabel(this)">âœ–</button>
                    </div>
                  </div>
                </div>
              </div>
              <div class="modal-footer">
                <button id="addLabelBtn" class="btn btn-primary" onclick="addLabel()">+</button>
                <button id="uploadBtn" class="btn btn-primary">Upload from file</button>
                <button id="saveBtn" class="btn btn-primary" onclick="saveLabels()">Save</button>
              </div>
          </div>
      </div>
    </div>

    <script src="{% static 'js/scripts/image-label/jquery-3.7.1.js' %}"></script>
    <script src="{% static 'js/scripts/image-label/bootstrap.bundle.min.js' %}"></script>
    <script src="{% static 'js/scripts/image-label/main.js' %}"></script>
    <!-- Font Awesome -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js" integrity="sha512-fD9DI5bZwQxOi7MhYWnnNPlvXdp/2Pj3XSTRrFs5FQa4mizyGLnJcN6tuvUS6LbmgN1ut+XGSABKvjN0H6Aoow==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script type="text/javascript">
    </script>
    <script>
      let uploaded_labels = JSON.parse(`{{image.uploaded_labels|safe}}`);
      let last_label_selected = {'name': '', 'color': ''};
      function get_labels_html(label){
        let uploaded_labels_html = ``;
        for(var i=0; i<uploaded_labels.length; i++ ){
          if(label.id==uploaded_labels[i].id){
            uploaded_labels_html = uploaded_labels_html + `<option value="${uploaded_labels[i]['id']}" selected>${uploaded_labels[i]['name']}</option>`
          } else {
            uploaded_labels_html = uploaded_labels_html + `<option value="${uploaded_labels[i]['id']}">${uploaded_labels[i]['name']}</option>`
          }
        }
        return uploaded_labels_html;
      }
      let zoomLevel = 1;
      let drag = false;
      let lastX = 0;
      let lastY = 0;
      let posX = 0;
      let posY = 0;
      let selectedTool = '';
      let drawing = false;
      let dragElement = false; // New variable to track if an element is being dragged
      let dragOffset = { x: 0, y: 0 }; // New variable to store the mouse offset when starting to drag
      let startX, startY;
      let startXTemp, startYTemp;
      let drawnElements = [];
      let selectedElement = null;
      let undoStack = [], redoStack = [];
      let hideElements = false;
      let drawingPolygon = false;
      let polygonPoints = [];
      let newlyAddedPolygons = [];
      let isCropping = false;
      let cropBox = null;
      let activeCorner = null; // Stores the active corner for resizing
      let isDraggingCrop = false;
      let minCropSize = 50;  // Minimum size for the crop box
      let cropDragOffsetX, cropDragOffsetY;
      let originalImage = null; // To store the original image data
      let croppedImageData = null; // To store the cropped image data

      const zoomInButton = document.getElementById("zoom-in");
      const zoomOutButton = document.getElementById("zoom-out");
      const selectButton = document.getElementById("btn-select");
      const drawLineButton = document.getElementById("btn-line");
      const blackoutButton = document.getElementById("btn-blackout");
      const colorPicker = document.getElementById("color-picker");
      const drawRectangleButton = document.getElementById("btn-rectangle");
      const polygonButton = document.getElementById("btn-polygon");
      const cropButton = document.getElementById("btn-crop");
      const resetButton = document.getElementById("btn-reset");
      // const drawCircleButton = document.getElementById("btn-circle");
      // const drawFree = document.getElementById("freeDraw");
      const selectElementButton = document.getElementById("btn-select-element");
      const removeButton = document.getElementById("removeElement");
      const hideElementsCheckbox = $("#hide-elements");
      const canvas = document.getElementById("image");
      const context = canvas.getContext('2d');
      const fitScreenButton = document.getElementById("btn-fit-screen");
      let lastCroppedImage = null;
      let lastCroppedImageWidth = null;
      let lastCroppedImageHeight = null;

      cropButton.onclick = function () {

        clearAllSelections();
        selectedTool = 'crop';
        row = ``;
        row = row + `<li>you can drag and resize crop box.</li>`;
        row = row + `<li>press escape to cancel.</li>`;
        row = row + `<li>press enter to crop image.</li>`;
        $('#how_to').empty();
        $('#how_to').append(row);
        setSelectedTool(cropButton);
        isCropping = true;
        unCrop();
      };

      resetButton.onclick = function () {
        lastCroppedImage = null;
        unCrop();
        fitToScreen();
        drawnElements = [];
        redrawImage();
        saveState();
      }
      fitScreenButton.onclick = function () {
        fitToScreen();
      };

      function fitToScreen(){
        zoomLevel = 1;
        posX = 0;
        posY = 0;
        redrawImage();
      }

      hideElementsCheckbox.change(function() {
        if (this.checked) {
          hideElements = true;
        } else {
          hideElements = false;
        }
        redrawImage();
      });

      // Load the image
      let img = new Image();
      img.src = "{{ image.media_file_anonymized.url }}";
      originalImage = new Image();
      originalImage.src = "{{ image.media_file_anonymized.url }}";

      img.onload = function() {
        canvas.width = img.width;
        canvas.height = img.height;
        context.lineWidth = 5;
        drawImageScaled(img, context);
        redrawImage();
      }
      if("{{relabel}}"=="yes"){
        var request = new XMLHttpRequest();
        request.open('GET', "{{components}}", true);
        request.send(null);
        request.onreadystatechange = function () {
        if (request.readyState === 4 && request.status === 200) {
          var type = request.getResponseHeader('Content-Type');
            if (type.indexOf("text") !== 1) {
              var json = request.responseText;
              drawnElements = JSON.parse(json);
              if(drawnElements.length>1 && drawnElements[0].type=='crop'){
                cropBox = drawnElements[0];
                cropImage();
              }
              redrawImage();
            }
          }
        }
      }

      zoomInButton.onclick = function () {
        zoomLevel += 0.1;
        redrawImage();
      };

      zoomOutButton.onclick = function () {
        zoomLevel -= 0.1;
        if (zoomLevel < 0.1) {
          zoomLevel = 0.1;  // prevent image from getting too small
        }
        redrawImage();
      };

      polygonButton.onclick = function () {
        clearAllSelections();
        selectedTool = 'polygon';
        $('#how_to').empty();
        row = ``;
        row = row + `<li>click on image to start.</li>`;
        row = row + `<li>each click makes a new point for polygon.</li>`;
        row = row + `<li>double click at last point to close polygon.</li>`;
        $('#how_to').empty();
        $('#how_to').append(row);
        setSelectedTool(polygonButton);
        polygonPoints = [];
        drawingPolygon = true;
      };

      function unCrop(){
        if (!originalImage) {
          img = originalImage;
        }
        if (originalImage) {
          img = originalImage;
          canvas.width = img.width;
          canvas.height = img.height;
          cropBox = {
              x: canvas.width / 4,
              y: canvas.height / 4,
              width: canvas.width / 2,
              height: canvas.height / 2,
              minSize: minCropSize
          };
          redrawImage();
        }
      }

      canvas.addEventListener('wheel', function(event) {
          event.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const x = (event.clientX - rect.left) / (rect.width / canvas.width) / zoomLevel - posX / zoomLevel;
          const y = (event.clientY - rect.top) / (rect.height / canvas.height) / zoomLevel - posY / zoomLevel;

           // Determine the scroll direction
          let delta = event.deltaY < 0 ? 0.1 : -0.1;
          // Update zoom level
          let newZoomLevel = zoomLevel + delta;
          if (newZoomLevel < 0.7) newZoomLevel = 0.7;

          // Calculate new position so that the point under the cursor remains in place
          posX = x - (x - posX) * (newZoomLevel / zoomLevel);
          posY = y - (y - posY) * (newZoomLevel / zoomLevel);

          // Update zoom level
          zoomLevel = newZoomLevel;

          // Redraw everything
          redrawImage();
      });


      selectButton.onclick = function () {
        clearAllSelections();
        selectedTool = 'select';
        row = ``;
        row = row + `<li>press and hold on image to drag</li>`;
        $('#how_to').empty();
        $('#how_to').append(row);
        setSelectedTool(selectButton);
      };

      drawLineButton.onclick = function () {
        clearAllSelections();
        row = ``;
        row = row + `<li>press and hold on image to draw</li>`;
        $('#how_to').empty();
        $('#how_to').append(row);
        selectedTool = 'drawLine';
        setSelectedTool(drawLineButton);
      };

      blackoutButton.onclick = function () {
        clearAllSelections();
        row = ``;
        row = row + `<li>press and hold on image to draw</li>`;
        $('#how_to').empty();
        $('#how_to').append(row);
        selectedTool = 'drawBlackout';
        setSelectedTool(blackoutButton);
      };

      drawRectangleButton.onclick = function () {
        clearAllSelections();
        row = ``;
        row = row + `<li>press and hold on image to draw</li>`;
        $('#how_to').empty();
        $('#how_to').append(row);
        selectedTool = 'drawRectangle';
        setSelectedTool(drawRectangleButton);
      };

      // drawCircleButton.onclick = function () {
      //   clearAllSelections();
      //   selectedTool = 'drawCircle';
      //   setSelectedTool(drawCircleButton);
      // };

      selectElementButton.onclick = function () {
        clearAllSelections();
        row = ``;
        row = row + `<li>press on any element to select it.</li>`;
        row = row + `<li>drag any selected element.</li>`;
        $('#how_to').empty();
        $('#how_to').append(row);
        selectedTool = 'selectElement';
        setSelectedTool(selectElementButton);
      };

      // drawFree.onclick = function () {
      //   clearAllSelections();
      //   selectedTool = 'FreeDraw';
      //   setSelectedTool(drawFree);
      // };

      document.getElementById('undo').addEventListener('click', function() {
        if (undoStack.length > 0) {
          let currentState = JSON.parse(JSON.stringify(drawnElements));

          // Only push if the state is different from the top of the Redo stack
          if (redoStack.length === 0 || JSON.stringify(redoStack[redoStack.length - 1]) !== JSON.stringify(currentState)) {
            redoStack.push(currentState); // save current state in redo stack
          }

          drawnElements = undoStack.pop(); // restore from undo stack
          if(drawnElements.length>0 && drawnElements[0].type!='crop'){
            unCrop();
          }
          redrawImage();
        }
        console.log(drawnElements);
      });

      document.getElementById('redo').addEventListener('click', function() {
        if (redoStack.length > 0) {
          let currentState = JSON.parse(JSON.stringify(drawnElements));

          // Only push if the state is different from the top of the Undo stack
          if (undoStack.length === 0 || JSON.stringify(undoStack[undoStack.length - 1]) !== JSON.stringify(currentState)) {
            undoStack.push(currentState); // save current state in undo stack
          }

          drawnElements = redoStack.pop(); // restore from redo stack
          if(drawnElements.length>1 && drawnElements[0].type=='crop'){
            unCrop();
            cropBox = drawnElements[0];
            cropImage();
          }
          redrawImage();
        }
        console.log(drawnElements);
      });

      function saveState() {
        // Clone elements array
        let currentState = JSON.parse(JSON.stringify(drawnElements));

        // Only push if the state is different from the top of the Undo stack
        if (undoStack.length === 0 || JSON.stringify(undoStack[undoStack.length - 1]) !== JSON.stringify(currentState)) {
          undoStack.push(currentState);
          redoStack = []; // clear redo stack
        }
      }

      function clearAllSelections() {
        drawnElements.forEach(element => {
          element.selected = false;
        });
        document.getElementById('btn-remove').disabled = true;
        document.getElementById('btn-edit-label').disabled = true;
        selectedElement = null;
        drawingPolygon = false;
        polygonPoints = [];
        cropBox = null;
        isCropping = false;
        isDraggingCrop = false;
        cancelCrop();
        redrawImage();
      }

      function setSelectedTool(toolButton) {
        // Clear existing selection
        const toolButtons = document.querySelectorAll('.tool-button');
        toolButtons.forEach(button => {
          button.classList.remove('active');
        });
        // Set new selection
        toolButton.classList.add('active');
      }
      canvas.addEventListener('dblclick', function(e) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left) / (rect.width / canvas.width) / zoomLevel - posX / zoomLevel;
        const mouseY = (e.clientY - rect.top) / (rect.height / canvas.height) / zoomLevel - posY / zoomLevel;
        polygonPoints.pop({ x: mouseX, y: mouseY });
        if (drawingPolygon && polygonPoints.length > 2) {
            // Connect the last point to the first
            polygonPoints.push(polygonPoints[0]);
            label = getCurrentLable();
            element = {
              type: 'polygon',
              points: polygonPoints.slice(),
              label_obj: label,
              label: label['name'],
              elementCount: drawnElements.length + 1,
              hover: false,
              color: label['color']
            }
            drawnElements.push(element);
            newlyAddedPolygons.push(element)
            polygonPoints = [];
            redrawImage();
        }
      });

      canvas.addEventListener('mousedown', function(e) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left) / (rect.width / canvas.width) / zoomLevel - posX / zoomLevel;
        const mouseY = (e.clientY - rect.top) / (rect.height / canvas.height) / zoomLevel - posY / zoomLevel;

        const mouseXTemp = (e.clientX - rect.left) / (rect.width / canvas.width) / zoomLevel - (posX);
        const mouseYTemp = (e.clientY - rect.top) / (rect.height / canvas.height) / zoomLevel - (posY);

        if (isCropping && cropBox) {
          // Check which corner is clicked for resizing
          activeCorner = getActiveResizeCorner(mouseX, mouseY, cropBox);
          if (activeCorner) {
              return;
          }
          // Check if user clicked inside the crop box (for dragging)
          if (mouseX >= cropBox.x && mouseX <= cropBox.x + cropBox.width &&
              mouseY >= cropBox.y && mouseY <= cropBox.y + cropBox.height) {
              isDraggingCrop = true;
              cropDragOffsetX = mouseX - cropBox.x;
              cropDragOffsetY = mouseY - cropBox.y;
          }
        }
        if (drawingPolygon) {
          startX = mouseX;
          startY = mouseY;
          startXTemp = mouseXTemp;
          startYTemp = mouseYTemp;
          console.log('adding');
          polygonPoints.push({ x: mouseX, temp_x: startXTemp, y: mouseY, temp_y: startYTemp });
        } else if (selectedTool === 'select') {
          const rect = canvas.getBoundingClientRect();
          lastX = e.clientX - rect.left;
          lastY = e.clientY - rect.top;
          drag = true;
        } else if (selectedTool === 'drawLine') {
          startX = mouseX;
          startY = mouseY;
          startXTemp = mouseXTemp;
          startYTemp = mouseYTemp;
          drawing = true;
        } else if (selectedTool === 'drawRectangle') {
          startX = mouseX;
          startY = mouseY;
          startXTemp = mouseXTemp;
          startYTemp = mouseYTemp;
          drawing = true;
        } else if (selectedTool === 'drawBlackout') {
          startX = mouseX;
          startY = mouseY;
          startXTemp = mouseXTemp;
          startYTemp = mouseYTemp;
          drawing = true;
        } else  if (selectedTool === 'drawCircle') {
          startX = mouseX;
          startY = mouseY;
          startXTemp = mouseXTemp;
          startYTemp = mouseYTemp;
          drawing = true;
        } else if (selectedTool === 'selectElement') {
          // Deselect any currently selected element
          drawnElements.forEach(elem => { elem.selected = false; });

          // Select the top-most element under the mouse click
          for (let i = drawnElements.length - 1; i >= 0; i--) {
            let elem = drawnElements[i];
            if (isWithinElement(mouseX, mouseY, elem)) {
              elem.selected = true;
              let center = getCenter(elem);
              document.getElementById('btn-remove').disabled = false;  // Enable the remove button
              //document.getElementById('btn-edit-label').disabled = false;  // Enable the remove button

              // Start dragging and store the offset
              dragElement = true;
              dragOffset = { x: mouseXTemp - center.x, y: mouseYTemp - center.y };
              break;
            }
          }
          redrawImage();
          saveState();
        } else if (selectedTool === 'FreeDraw') {
          startX = mouseX;
          startY = mouseY;
          drawing = true;
          drawnElements.push({
            type: 'FreeDraw',
            points: [{x: mouseX, y: mouseY}],
            color: colorPicker.value,
            startX: mouseX,
            startY: mouseY,
            endX: mouseX,
            endY: mouseY
          });
        }
      });

      function removeDrawnElement() {
        // Find the selected element
        for (let i = 0; i < drawnElements.length; i++) {
          if (drawnElements[i].selected) {
            // Remove the selected element
            drawnElements.splice(i, 1);
            break;
          }
        }
        for (let i = 0; i < drawnElements.length; i++) {
          if (drawnElements[i].elementCount > -1) {
            // Update the element count
            drawnElements[i].elementCount = i + 1;
          }
        }
        // Clear all selections and disable the remove button
        clearAllSelections();
      }

      document.getElementById('btn-remove').addEventListener('click', removeDrawnElement);

      document.addEventListener('keydown', function(event) {
        if (event.key === 'Delete' || event.key === 'Backspace') {
          removeDrawnElement();
        }
        if (event.key === 'Enter' && isCropping && cropBox) {
          cropImage(); // Perform cropping
          saveState();
          drawnElements = [{
            type: 'crop',
            x: cropBox.x,
            y: cropBox.y,
            width: cropBox.width,
            height: cropBox.height,
            minSize: cropBox.minSize,
          }];
          cropBox = null;
        }
        if (event.key === 'Escape' && isCropping && cropBox) {
          cancelCrop();
        }
      });

      document.getElementById('btn-edit-label').addEventListener('click', function() {
        // Find the selected element
        for (let i = 0; i < drawnElements.length; i++) {
          elem = drawnElements[i]
          if (elem.selected) {
            // Remove the selected element
            elem.label = prompt("Please enter the label", elem.label);
            last_label_selected = label;
            break;
          }
        }
        // Clear all selections and disable the remove button
        redrawImage();
        clearAllSelections();
      });

      function editElement(index){
        var elem = drawnElements[index];
        label_id = $(`#E${elem.elementCount}`).find('#label-select').val();
        new_label = getLabelById(label_id);
        elem.label = new_label['name'];
        elem.color = new_label['color'];
        elem.label_obj = new_label;
        last_label_selected = new_label;
        redrawImage();
      }

      function isWithinElement(mouseX, mouseY, element) {
        if (element.type=='polygon' && isPointInPolygon(mouseX, mouseY, element)){
          return true;
        } if (element.type === 'rectangle') {
          let startX = Math.min(element.startX, element.endX);
          let endX = Math.max(element.startX, element.endX);
          let startY = Math.min(element.startY, element.endY);
          let endY = Math.max(element.startY, element.endY);
          return mouseX > startX && mouseX < endX && mouseY > startY && mouseY < endY;
        } if (element.type === 'blackout') {
          let startX = Math.min(element.startX, element.endX);
          let endX = Math.max(element.startX, element.endX);
          let startY = Math.min(element.startY, element.endY);
          let endY = Math.max(element.startY, element.endY);
          return mouseX > startX && mouseX < endX && mouseY > startY && mouseY < endY;
        } else if (element.type === 'circle') {
          let dx = mouseX - element.centerX;
          let dy = mouseY - element.centerY;
          return dx * dx + dy * dy <= element.radius * element.radius;
        } else if (element.type === 'line') {
          // This is a simplification, you may want to use a better distance-to-line-segment algorithm
          return Math.abs((element.endY - element.startY) * mouseX - (element.endX - element.startX) * mouseY +
                          element.endX * element.startY - element.endY * element.startX) /
                Math.sqrt(Math.pow(element.endY - element.startY, 2) + Math.pow(element.endX - element.startX, 2)) < 5;
        } else if (element.type === 'FreeDraw') {
          // Compute the bounding box of the free drawn element
          const xCoords = element.points.map(p => p.x);
          const yCoords = element.points.map(p => p.y);
          const boundingBox = {
            startX: Math.min(...xCoords),
            startY: Math.min(...yCoords),
            width: Math.max(...xCoords) - Math.min(...xCoords),
            height: Math.max(...yCoords) - Math.min(...yCoords),
          };

          // Check if the mouse is within the bounding box
          return mouseX > boundingBox.startX && mouseX < boundingBox.startX + boundingBox.width &&
                mouseY > boundingBox.startY && mouseY < boundingBox.startY + boundingBox.height;
        }
        return false;
      }

      canvas.addEventListener('mousemove', function(e) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left) / (rect.width / canvas.width) / zoomLevel - posX / zoomLevel;
        const mouseY = (e.clientY - rect.top) / (rect.height / canvas.height) / zoomLevel - posY / zoomLevel;
        const mouseXTemp = (e.clientX - rect.left) / (rect.width / canvas.width) / zoomLevel - (posX);
        const mouseYTemp = (e.clientY - rect.top) / (rect.height / canvas.height) / zoomLevel - (posY);


        if (dragElement==false && drawing==false && drag==false && hideElements==true) {
          drawnElements.forEach(elem => {
            let center = getCenter(elem);
            var dx = mouseX - (center.x + posX);
            var dy = mouseY - (center.y + posY);
            var distance = Math.sqrt(dx * dx + dy * dy);
            elem.hover = (distance < 10)
            redrawImage();
          })
        }
        if (dragElement==false && drawing==false && drag==false) {
          for (let i = 0; i < drawnElements.length; i++) {
              let elem = drawnElements[i];
              let center = getCenter(elem);
              var dx = mouseX - (center.x + posX);
              var dy = mouseY - (center.y + posY);
              var distance = Math.sqrt(dx * dx + dy * dy);
              if ((distance < 25 && elem.elementCount>-1) || (elem.type=='polygon' && isPointInPolygon(mouseX, mouseY, elem))) {
                  $(`#E${elem.elementCount}`).css('color', 'red');
                  $(`#hovered-lebel`).text(elem.label_obj['name']);
                  break;
              } else {
                  $(`#E${elem.elementCount}`).css('color', 'black');
                  $(`#hovered-lebel`).text("Hover on the highlighted portion to see the associated label");
              }
          }
        }
        if (activeCorner) {
          // Resizing based on the active corner
          resizeCropBox(mouseX, mouseY, cropBox, activeCorner);
          redrawImage();
        } else if (isDraggingCrop) {
            // Drag the crop box
            cropBox.x = mouseX - cropDragOffsetX;
            cropBox.y = mouseY - cropDragOffsetY;
            redrawImage();
        }
        if (drawingPolygon) {
          if (polygonPoints.length > 0) {
            redrawImage();
            context.save();
            context.scale(zoomLevel, zoomLevel);
            context.translate(posX, posY);
            context.beginPath();
            context.moveTo(polygonPoints[0].temp_x, polygonPoints[0].temp_y);
            for (let i = 1; i < polygonPoints.length; i++) {
              context.lineTo(polygonPoints[i].temp_x, polygonPoints[i].temp_y);
            }
            context.lineTo(mouseXTemp, mouseYTemp);
            context.strokeStyle = getCurrentLable()['color'];
            context.stroke();
            context.restore();

            polygonPoints.forEach(point => {
              context.beginPath();
              context.arc(point.x + posX, point.y + posY, 10, 0, 2 * Math.PI); // Draw small circles at vertices
              context.fillStyle = getCurrentLable()['color'];
              context.fill();
            });
          }
        }
        if (drag && selectedTool === 'select') {
          const rect = canvas.getBoundingClientRect();
          const newX = e.clientX - rect.left;
          const newY = e.clientY - rect.top;
          posX += newX - lastX;
          posY += newY - lastY;
          lastX = newX;
          lastY = newY;
          redrawImage();
          saveState();
        } else if (drawing && selectedTool === 'drawLine') {
          redrawImage();
          context.save();
          context.scale(zoomLevel, zoomLevel);
          context.translate(posX, posY);
          context.beginPath();
          context.moveTo(startXTemp, startYTemp);
          context.lineTo(mouseXTemp, mouseYTemp);
          context.strokeStyle = colorPicker.value;
          context.stroke();
          // drawArrowhead(startX, startY, mouseX, mouseY, 10, colorPicker.value);
          context.restore();
        } else if (drawing && selectedTool === 'drawBlackout') {
          redrawImage();
          saveState();
          context.save();
          context.scale(zoomLevel, zoomLevel);
          context.translate(posX, posY);
          context.beginPath();
          context.rect(startXTemp, startYTemp, mouseXTemp - startXTemp, mouseYTemp - startYTemp);
          context.strokeStyle = colorPicker.value;
          context.stroke();
          context.restore();
        } else if (drawing && selectedTool === 'drawRectangle') {
          redrawImage();
          saveState();
          context.save();
          context.scale(zoomLevel, zoomLevel);
          context.translate(posX, posY);
          context.beginPath();
          context.rect(startXTemp, startYTemp, mouseXTemp - startXTemp, mouseYTemp - startYTemp);
          context.strokeStyle = colorPicker.value;
          context.stroke();
          context.restore();
        } else if (drawing && selectedTool === 'drawCircle') {
          redrawImage();
          saveState();
          context.save();
          context.scale(zoomLevel, zoomLevel);
          context.translate(posX, posY);
          const radius = Math.sqrt(Math.pow(mouseX - startX, 2) + Math.pow(mouseY - startY, 2));
          context.beginPath();
          context.arc(startX, startY, radius, 0, 2 * Math.PI);
          context.strokeStyle = colorPicker.value;
          context.stroke();
          context.restore();
        } else if (dragElement && selectedTool === 'selectElement') {
          // If an element is being dragged, adjust its position
          selectedElement = drawnElements.find(elem => elem.selected);
          let center = getCenter(selectedElement);
          center.x = mouseXTemp - dragOffset.x;
          center.y = mouseYTemp - dragOffset.y;
          setCenter(selectedElement, center);

          // If the cursor is on the selected element, change the cursor to the move cursor
          if (isWithinElement(mouseX, mouseY, selectedElement)) {
            canvas.style.cursor = "move";
          } else {
            canvas.style.cursor = "default";
          }

          redrawImage();
        } else if (drawing && selectedTool === 'FreeDraw') {
          const currentElement = drawnElements[drawnElements.length - 1];
          currentElement.points.push({x: mouseX, y: mouseY});
          currentElement.startX = Math.min(currentElement.startX, mouseX);
          currentElement.startY = Math.min(currentElement.startY, mouseY);
          currentElement.endX = Math.max(currentElement.endX, mouseX);
          currentElement.endY = Math.max(currentElement.endY, mouseY);
          redrawImage();
        }
        if (selectedTool === 'select') {
          canvas.style.cursor = "grab";
        }else{
          canvas.style.cursor = "default";
        }
      });

      canvas.addEventListener('mouseup', function(e) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left) / (rect.width / canvas.width) / zoomLevel - posX / zoomLevel;
        const mouseY = (e.clientY - rect.top) / (rect.height / canvas.height) / zoomLevel - posY / zoomLevel;


        if (drag && selectedTool === 'select') {
          drag = false;
        } else if (drawing && selectedTool === 'drawLine') {
          const dx = mouseX - startX;
          const dy = mouseY - startY;
          size = Math.sqrt(dx * dx + dy * dy);
          if(size > 20){
            drawnElements.push({
              type: 'line',
              startX: startX,
              startY: startY,
              endX: mouseX,
              endY: mouseY,
              color: colorPicker.value,
              hover: false,
            });
          }
          drawing = false;
        } else if (drawing && selectedTool === 'drawBlackout') {
          const width = Math.abs(mouseX - startX);
          const height = Math.abs(mouseY - startY);
          size = width * height;
          if(size > 10){
            drawnElements.push({
              type: 'blackout',
              startX: startX,
              startY: startY,
              endX: mouseX,
              endY: mouseY,
              width: Math.abs(mouseX - startX),
              height: Math.abs(mouseY - startY),
              img_w: img.width,
              img_h: img.height,
              color: colorPicker.value,
              hover: false,
            });
          }
          drawing = false;
        } else if (drawing && selectedTool === 'drawRectangle') {
          const width = Math.abs(mouseX - startX);
          const height = Math.abs(mouseY - startY);
          size = width * height;
          if(size > 10){
            label = getCurrentLable();
            drawnElements.push({
              type: 'rectangle',
              startX: startX,
              startY: startY,
              endX: mouseX,
              endY: mouseY,
              width: Math.abs(mouseX - startX),
              height: Math.abs(mouseY - startY),
              img_w: img.width,
              img_h: img.height,
              label_obj: label,
              label: label['name'],
              elementCount: drawnElements.length + 1,
              hover: false,
              color: label['color']
            });
          }
          drawing = false;
        } else if (drawing && selectedTool === 'drawCircle') {
          const label = prompt('What do you want to label this circle?');
          const radius = Math.sqrt(Math.pow(mouseX - startX, 2) + Math.pow(mouseY - startY, 2));
          drawnElements.push({
            type: 'circle',
            centerX: startX,
            centerY: startY,
            radius: radius,
            label: label,
            hover: false,
            color: colorPicker.value
          });
          drawing = false;
        } else if (dragElement && selectedTool === 'selectElement') {
          dragElement = false;
        } else if (drawing && selectedTool === 'FreeDraw') {
          const label = prompt('What do you want to label this free drawn element?');
          const currentElement = drawnElements[drawnElements.length - 1];
          currentElement.label = label;
          currentElement.hover = false;
          drawing = false;
        }
        isDraggingCrop = false;
        activeCorner = null;
        saveState();
        redrawImage();
      });

      function getActiveResizeCorner(mouseX, mouseY, cropBox) {
        const corners = {
            topLeft: [cropBox.x, cropBox.y],
            topRight: [cropBox.x + cropBox.width, cropBox.y],
            bottomLeft: [cropBox.x, cropBox.y + cropBox.height],
            bottomRight: [cropBox.x + cropBox.width, cropBox.y + cropBox.height]
        };

        const tolerance = 10; // Tolerance for clicking near the corners

        for (let corner in corners) {
            let [cx, cy] = corners[corner];
            if (Math.abs(mouseX - cx) <= tolerance && Math.abs(mouseY - cy) <= tolerance) {
                return corner;
            }
        }
        return null;
      }
      function resizeCropBox(mouseX, mouseY, cropBox, corner) {
        const minSize = cropBox.minSize;
        switch (corner) {
            case 'topLeft':
                const newWidthTL = cropBox.x + cropBox.width - mouseX;
                const newHeightTL = cropBox.y + cropBox.height - mouseY;
                if (newWidthTL > minSize) {
                    cropBox.x = mouseX;
                    cropBox.width = newWidthTL;
                }
                if (newHeightTL > minSize) {
                    cropBox.y = mouseY;
                    cropBox.height = newHeightTL;
                }
                break;
            case 'topRight':
                const newWidthTR = mouseX - cropBox.x;
                const newHeightTR = cropBox.y + cropBox.height - mouseY;
                if (newWidthTR > minSize) {
                    cropBox.width = newWidthTR;
                }
                if (newHeightTR > minSize) {
                    cropBox.y = mouseY;
                    cropBox.height = newHeightTR;
                }
                break;
            case 'bottomLeft':
                const newWidthBL = cropBox.x + cropBox.width - mouseX;
                const newHeightBL = mouseY - cropBox.y;
                if (newWidthBL > minSize) {
                    cropBox.x = mouseX;
                    cropBox.width = newWidthBL;
                }
                if (newHeightBL > minSize) {
                    cropBox.height = newHeightBL;
                }
                break;
            case 'bottomRight':
                const newWidthBR = mouseX - cropBox.x;
                const newHeightBR = mouseY - cropBox.y;
                if (newWidthBR > minSize) {
                    cropBox.width = newWidthBR;
                }
                if (newHeightBR > minSize) {
                    cropBox.height = newHeightBR;
                }
                break;
        }
      }

      function isPointInPolygon(mouseX, mouseY, polygon) {
        let inside = false;
        const points = polygon.points;

        // Loop through each edge of the polygon
        for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
            const xi = points[i].x, yi = points[i].y;
            const xj = points[j].x, yj = points[j].y;

            // Check if the point is between the y coordinates of the current edge
            const intersect = ((yi > mouseY) !== (yj > mouseY)) &&
                              (mouseX < (xj - xi) * (mouseY - yi) / (yj - yi) + xi);

            if (intersect) {
                inside = !inside; // Toggle the inside flag
            }
        }

        return inside;
      }


      function getCenter(element) {
        switch (element.type) {
          case 'polygon':
            let sumX = 0;
            let sumY = 0;
            const points = element.points;
            const numPoints = points.length;

            // Sum all x and y coordinates of the polygon's vertices
            for (let i = 0; i < numPoints; i++) {
                sumX += points[i].x;
                sumY += points[i].y;
            }

            // Calculate the centroid
            const centerX = sumX / numPoints;
            const centerY = sumY / numPoints;

            return { x: centerX, y: centerY };
          case 'rectangle':
            return {
              x: (element.startX + element.endX) / 2,
              y: (element.startY + element.endY) / 2
            };
          case 'blackout':
            return {
              x: (element.startX + element.endX) / 2,
              y: (element.startY + element.endY) / 2
            };
          case 'circle':
            return {
              x: element.centerX,
              y: element.centerY
            };
          case 'line':
            return {
              x: (element.startX + element.endX) / 2,
              y: (element.startY + element.endY) / 2
            };
          case 'FreeDraw':
            return {
              x: element.startX,
              y: element.startY
            };
          // Add other shapes here...
          default:
            return { x: 0, y: 0 };
        }
      }

      function setCenter(element, center) {
        let width, height;
        switch (element.type) {
          case 'polygon':
            const currentCenter = getCenter(element);
            const deltaX = center.x - currentCenter.x;
            const deltaY = center.y - currentCenter.y;

            let points = element.points;
            if(newlyAddedPolygons.includes(element)){
              for(let i = 1; i < points.length; i++) {
                  points[i].x += deltaX;
                  points[i].y += deltaY;
              }
            }
            else{
              for(let i = 0; i < points.length; i++) {
                  points[i].x += deltaX;
                  points[i].y += deltaY;
              }
            }
            break;
          case 'rectangle':
            width = Math.abs(element.startX - element.endX);
            height = Math.abs(element.startY - element.endY);
            element.startX = center.x - width / 2;
            element.endX = center.x + width / 2;
            element.startY = center.y - height / 2;
            element.endY = center.y + height / 2;
            break;
          case 'blackout':
            width = Math.abs(element.startX - element.endX);
            height = Math.abs(element.startY - element.endY);
            element.startX = center.x - width / 2;
            element.endX = center.x + width / 2;
            element.startY = center.y - height / 2;
            element.endY = center.y + height / 2;
            break;
          case 'circle':
            element.centerX = center.x;
            element.centerY = center.y;
            break;
          case 'line':
            width = element.endX - element.startX;
            height = element.endY - element.startY;
            element.startX = center.x - width / 2;
            element.endX = center.x + width / 2;
            element.startY = center.y - height / 2;
            element.endY = center.y + height / 2;
            break;
          case 'FreeDraw':
            const dx = center.x - element.startX;
            const dy = center.y - element.startY;
            element.startX = center.x;
            element.startY = center.y;
            for(let i = 0; i < element.points.length; i++) {
              element.points[i].x += dx;
              element.points[i].y += dy;
            }
            break;
          // Add other shapes here...
        }
      }

      function drawImageScaled(img, ctx) {
        const ratio = Math.min(canvas.width / img.width, canvas.height / img.height);
        const centerShift_x = (canvas.width - img.width * ratio) / 2 + posX;
        const centerShift_y = (canvas.height - img.height * ratio) / 2 + posY;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, img.width, img.height, centerShift_x, centerShift_y, img.width * ratio, img.height * ratio);
      }

      function drawResizeHandles(cropBox) {
        const handleSize = 20;

        context.fillStyle = 'red';

        // Top-left
        context.fillRect(cropBox.x - handleSize / 2, cropBox.y - handleSize / 2, handleSize, handleSize);

        // Top-right
        context.fillRect(cropBox.x + cropBox.width - handleSize / 2, cropBox.y - handleSize / 2, handleSize, handleSize);

        // Bottom-left
        context.fillRect(cropBox.x - handleSize / 2, cropBox.y + cropBox.height - handleSize / 2, handleSize, handleSize);

        // Bottom-right
        context.fillRect(cropBox.x + cropBox.width - handleSize / 2, cropBox.y + cropBox.height - handleSize / 2, handleSize, handleSize);
      }

      function cropImage() {
        // Get cropped portion of the image from the canvas
        canvas.width = cropBox.width;
        canvas.height = cropBox.height;
        lastCroppedImageHeight = cropBox.height;
        lastCroppedImageWidth = cropBox.width;
        context.clearRect(0, 0, canvas.width, canvas.height);
        context.drawImage(img, cropBox.x, cropBox.y, cropBox.width, cropBox.height, 0, 0, canvas.width, canvas.height);
        img = new Image();
        lastCroppedImage = new Image();
        img.src = canvas.toDataURL();
        lastCroppedImage.src = canvas.toDataURL();
        img.onload = function() {
          fitToScreen();
        }
        isCropping = false;
      }

      function cancelCrop(){
        if(lastCroppedImage){
          img = lastCroppedImage;
          canvas.width = lastCroppedImageWidth;
          canvas.height = lastCroppedImageHeight;
        }
        isCropping = false;
        fitToScreen();
        cropBox = null;
        redrawImage();
      }

      function redrawImage() {
        $("#keywords").empty();
        context.clearRect(0, 0, canvas.width, canvas.height);
        context.save();
        context.translate(posX, posY);
        context.scale(zoomLevel, zoomLevel);
        context.translate(-posX, -posY);
        drawImageScaled(img, context);
        context.fillStyle = '#FFFFFF';
        if (isCropping && cropBox) {
          //context.save();
          context.beginPath();
          context.rect(cropBox.x, cropBox.y, cropBox.width, cropBox.height);
          context.strokeStyle = 'black';
          context.lineWidth = 5;
          context.stroke();

          drawResizeHandles(cropBox);
          context.restore();
          return;
        }
        drawnElements.forEach(elem => {
          context.lineWidth = 5;
          if (elem.hover == false && hideElements==true) {
            let center = getCenter(elem);
            let gradient = context.createRadialGradient(center.x, center.y, 0, center.x, center.y, 5);
            gradient.addColorStop(0, 'white');
            gradient.addColorStop(0.5, 'blue');
            gradient.addColorStop(1, 'green');

            context.beginPath();
            context.arc(center.x + posX, center.y + posY, 5, 0, 2 * Math.PI, false);
            context.fillStyle = gradient;
            context.fill();
          } else {
            if (elem.type === 'polygon') {
              context.beginPath();
              context.moveTo(elem.points[0].x + posX, elem.points[0].y + posY);
              for (let i = 1; i < elem.points.length; i++) {
                  context.lineTo(elem.points[i].x + posX, elem.points[i].y + posY);
              }
              context.closePath(); // Close the path to form a polygon
              context.strokeStyle = elem.color;
              context.stroke();

              // Fill the polygon
              const fillColorWithTransparency = hexToRGBA(elem.color);
              context.fillStyle = fillColorWithTransparency;
              context.fill();

              if (elem.selected) {
                context.setLineDash([10, 10]);  // Add a dashed outline for selected polygons
                context.lineWidth = 5;  // Make the selection outline a bit thicker
                context.strokeStyle = '#00FF00';  // Highlight color for selected element
                context.stroke();

                // Optionally, you can draw little circles around each vertex (for example)
                elem.points.forEach(point => {
                    context.beginPath();
                    context.arc(point.x + posX, point.y + posY, 5, 0, 2 * Math.PI); // Draw small circles at vertices
                    context.fillStyle = '#FF0000';  // Red circles at vertices
                    context.fill();
                });
              }
            } else if (elem.type === 'line') {
              context.beginPath();
              context.moveTo(elem.startX + posX, elem.startY + posY);
              context.lineTo(elem.endX + posX, elem.endY + posY);
              context.strokeStyle = elem.color;
              context.stroke();
              // drawArrowhead(elem.startX + posX, elem.startY + posY, elem.endX + posX, elem.endY + posY, 10, elem.color);
            } else if (elem.type === 'rectangle') {
              context.beginPath();
              context.rect(elem.startX + posX, elem.startY + posY, elem.endX - elem.startX, elem.endY - elem.startY);
              context.strokeStyle = elem.label_obj['color'];
              const fillColorWithTransparency = hexToRGBA(elem.label_obj['color']);
              context.fillStyle = fillColorWithTransparency;
              context.fill();
              context.stroke();
            } else if (elem.type === 'blackout') {
              context.beginPath();
              context.rect(elem.startX + posX, elem.startY + posY, elem.endX - elem.startX, elem.endY - elem.startY);
              context.strokeStyle = elem.color;
              context.fillStyle = elem.color;
              context.fill();
              context.stroke();
            } else if (elem.type === 'circle') {
              context.beginPath();
              context.arc(elem.centerX + posX, elem.centerY + posY, elem.radius, 0, 2 * Math.PI);
              context.strokeStyle = elem.color;
              context.stroke();
            } else if (elem.type === 'FreeDraw') {
              context.beginPath();
              context.moveTo(elem.points[0].x + posX, elem.points[0].y + posY);
              for (let i = 1; i < elem.points.length; i++) {
                context.lineTo(elem.points[i].x + posX, elem.points[i].y + posY);
              }
              context.strokeStyle = elem.color;
              context.stroke();
            }
            if (elem.label_obj) {
              let center = getCenter(elem);
              const labelMargin = 5;
              const fontSize = 16;
              const labelWidth = context.measureText(elem.elementCount).width;
              const labelHeight = fontSize;

              let labelX = center.x + posX;
              let labelY = center.y + posY - (elem.endY - elem.startY) / 2 - labelHeight - labelMargin;

              // Check if label would be outside the canvas, and adjust its position
              if (labelY - labelHeight < 0) {
                labelY = center.y + posY + (elem.endY - elem.startY) / 2 + labelHeight + labelMargin;
                if (labelY + labelHeight > canvas.height) {
                  if (center.x + labelWidth / 2 + posX + labelMargin < canvas.width) {
                    labelX = center.x + (elem.endX - elem.startX) / 2 + posX + labelMargin;
                    labelY = center.y + posY;
                  } else {
                    labelX = center.x - (elem.endX - elem.startX) / 2 + posX - labelWidth - labelMargin;
                    labelY = center.y + posY;
                  }
                }
              }
              context.font = fontSize + "px Arial";
              context.fillStyle = elem.label_obj['color'];
              context.textAlign = "center"; // Align the text to the center
              //context.fillText("E" + elem.elementCount, labelX, labelY);
              //$("#keywords").append(`<li id="E${elem.elementCount}">E${elem.elementCount} -> ${elem.label}</li>`);
              $("#keywords").append(`<li style="background-color: ${hexToRGBA(elem.label_obj['color'])}" id="E${elem.elementCount}">
                      <select id="label-select" onchange="editElement(${drawnElements.indexOf(elem)});">
                        ${get_labels_html(elem.label_obj)}
                      </select>
                    </li>`);
            }
            if (elem.selected) {
              context.setLineDash([10, 10]);  // Add a dashed outline for selected polygons
              context.lineWidth = 5;  // Make the selection outline a bit thicker
              context.strokeStyle = '#00FF00';  // Highlight color for selected element
              context.stroke();
              context.setLineDash([]);
            }
          }
        });
        context.restore();
      }

      function hexToRGBA(hex) {
        var gradientFactor = 20;
        gradientFactor = gradientFactor / 100;
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${gradientFactor})`;
      }

      function drawArrowhead(fromX, fromY, toX, toY, radius, color) {
        let x_center = toX;
        let y_center = toY;

        let angle;
        let x;
        let y;

        context.beginPath();

        angle = Math.atan2(toY - fromY, toX - fromX);
        x = radius * Math.cos(angle) + x_center;
        y = radius * Math.sin(angle) + y_center;

        context.moveTo(x, y);

        angle += (1/3)*(2*Math.PI);
        x = radius * Math.cos(angle) + x_center;
        y = radius * Math.sin(angle) + y_center;

        context.lineTo(x, y);

        angle += (1/3)*(2*Math.PI);
        x = radius * Math.cos(angle) + x_center;
        y = radius * Math.sin(angle) + y_center;

        context.lineTo(x, y);
        context.closePath();

        context.fillStyle = color;
        context.fill();
      }

      function getCurrentLable(){
        if(last_label_selected['name']){
          label = last_label_selected
        }else{
          label = uploaded_labels.length>0 ? uploaded_labels[0] : '';
        }
        return label;
      }
      function myFunction(){
        clearAllSelections();
        fitToScreen();
        document.getElementById('my_components').value = JSON.stringify(drawnElements);
        document.getElementById('my_hidden').value = canvas.toDataURL('image/png');
        document.getElementById('uploaded_labels').value = JSON.stringify(uploaded_labels);
        document.getElementById('all_labels').value = drawnElements.filter(elem => elem.elementCount !== undefined && elem.label_obj['name'] !== undefined)
                                                                      .map(elem => `E${elem.elementCount} -> ${elem.label_obj['name']}`);
        document.forms["form1"].submit();
      }
    </script>
  <script>
      function getRandomColor() {
        // Generate a random number between 0 and 255 for each color component
        const red = Math.floor(Math.random() * 256);
        const green = Math.floor(Math.random() * 256);
        const blue = Math.floor(Math.random() * 256);

        // Convert each color component into a hexadecimal string and concatenate them
        const color = '#' + ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16).slice(1);
        return color;
      }

      function getRandomId() {
        // Generate a random ID based on the current timestamp and a random number
        return 'id_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
      }

      function getLabelById(id){
        var foundLabel = uploaded_labels.find(function(label) {
          return label.id === id;
        });
        return foundLabel;
      }

      function addLabel() {
        var labelContainer = document.getElementById('labelContainer');
        var labelInputs = document.getElementsByClassName('label-text');
        var allFilled = true;

        for (var i = 0; i < labelInputs.length; i++) {
          if (labelInputs[i].value === '') {
            labelInputs[i].classList.add('error');
            allFilled = false;
          } else {
            labelInputs[i].classList.remove('error');
          }
        }

        if (allFilled) {
          var newLabelRow = document.createElement('div');
          newLabelRow.className = 'row mt-1 label-input';
          newLabelRow.id = getRandomId();
          newLabelRow.innerHTML =`<div class="col-8">
                                    <input class="label-text form-control" type="text" placeholder="Insert label">
                                  </div>
                                  <div class="col-2">
                                    <input class="color-input form-control" value="${getRandomColor()}" type="color">
                                  </div>
                                  <div class="col-2">
                                    <button class="delete-button btn btn-danger" onclick="deleteLabel(this)">âœ–</button>
                                  </div>`;
          labelContainer.appendChild(newLabelRow);
        }
      }
      function openEditLabels(){
        var labelContainer = document.getElementById('labelContainer');
        if(uploaded_labels.length>0){
          labelContainer.innerHTML = '';
          for(var i=0; i<uploaded_labels.length; i++ ){
            var newLabelRow = document.createElement('div');
            newLabelRow.className = 'row mt-1 label-input';
            newLabelRow.id = uploaded_labels[i]['id'];
            newLabelRow.innerHTML =`<div class="col-8">
                                      <input class="label-text form-control" value="${uploaded_labels[i]['name']}" type="text" placeholder="Insert label">
                                    </div>
                                    <div class="col-2">
                                      <input class="color-input form-control" value="${uploaded_labels[i]['color']}" type="color">
                                    </div>
                                    <div class="col-2">
                                      <button class="delete-button btn btn-danger" onclick="deleteLabel(this)">âœ–</button>
                                    </div>`;
            labelContainer.appendChild(newLabelRow);
          }
        }
        $('#EditModel').modal('show');
      }

      function deleteLabel(button) {
        var labelRow = button.parentElement.parentElement;
        labelRow.remove();
      }

      function changeAllElementsAfterEditing() {
        // Filter drawnElements to exclude elements with deleted labels
        drawnElements = drawnElements.filter(elem => {
            const new_label = getLabelById(elem.label_obj['id']);
            if (new_label) {
                // If the label exists, update the label_obj and keep the element
                elem.label_obj = new_label;
                return true; // Keep the element
            } else {
                // If the label doesn't exist, log message and remove the element
                console.log("LABEL DELETED");
                return false; // Remove the element
            }
        });

        // Redraw the image with the updated drawnElements array
        redrawImage();
    }


      function saveLabels() {
        var labels = document.querySelectorAll('.label-input');
        var labelsArray = Array.from(labels).map(function(label) {
            return {"name": label.querySelector('.label-text').value,
                    "color": label.querySelector('.color-input').value,
                    "id": (label.id || getRandomId())};
        }).filter(Boolean);
        uploaded_labels = labelsArray;
        changeAllElementsAfterEditing();
        $('#EditModel').modal('toggle');
      }
      $(document).ready(function() {
        if(uploaded_labels.length==0){
          $("#btn-edit-labels").click();
        }
        $('#uploadBtn').on('click', function() {
          $('#fileInput').click();
        });
        $('#fileInput').on('change', function(e) {
          var file = e.target.files[0];
          if (!file) {
            return;
          }

          var reader = new FileReader();
          reader.onload = function(e) {
            var contents = e.target.result;
            processFile(contents);
          };
          reader.readAsText(file);
        });

        // Optional: clear the file input after upload
        $('#EditModel').on('hidden.bs.modal', function() {
          $('#fileInput').val('');
        });
      });
      function processFile(contents) {
        var labels = contents.split('\n');
        $('#labelContainer').empty(); // Clear existing labels

        labels.forEach(function(label) {
          if (label.trim().length > 0) {
            addLabelWithValue(label.trim());
          }
        });
      }
      function addLabelWithValue(value) {
        var labelContainer = $('#labelContainer');
        var newLabelRow = $('<div class="row mt-1 label-input"></div>');
        newLabelRow.id = getRandomId();
        var inputColumn = $('<div class="col-8"></div>');
        var colorColumn = $('<div class="col-2"></div>');
        var deleteColumn = $('<div class="col-2"></div>');

        var input = $('<input class="label-text form-control" type="text" placeholder="Insert label">').val(value);
        var color = $(`<input class="color-input form-control" type="color">`).val(getRandomColor());
        var deleteButton = $('<button class="delete-button btn btn-danger">âœ–</button>').on('click', function() {
            $(this).closest('.row').remove();
        });

        inputColumn.append(input);
        colorColumn.append(color);
        deleteColumn.append(deleteButton);
        newLabelRow.append(inputColumn).append(colorColumn).append(deleteColumn);
        labelContainer.append(newLabelRow);
      }
  </script>
</body>
</html>
